[{"title":"原型函数Construction解析","url":"/2016/07/06/JavaScript-constructor/","content":"\n### 理解原型之间的关系\n\n```\n    testOne() {};\n    testOne.prototype\n    // Object {\n            constructor: a()\n                    arguments: null\n                    caller: null\n                    length: 0\n                    name:\"a\"\n                    prototype: Object\n                    __proto__: ()\n                    <function scope>\n                    //注意层级关系\n            __proto__: Object\n        }\n        \n        \n    testOne.length\n    // output: 0\n    \n    \n    testOne.prototype.name = '2';\n    testOne.name\n    // output: 'a';\n```\n**注意**: 这里输出为'a'，而不是２，它会去查constructor里面的name，因为prototype.constructor是会指回testOne，如果要获取＇２＇，只能testOne.prototype.name来获取.\n\t\n```\t\t\t\n    const testTwo = new testOne();\n    testTwo.prototype\n    //output: undefined\n```\n\n**注意**: 每创建一个函数才会创建它的prototype对象，使用new，不会创建prototype对象\n    \n```   \n    testTwo.constructor\n    //output: testOne(){}\n    \n    testTwo.constructor.name = 'b';\n    testTwo.name\n    // output: testTwo\n    \n    Object.getOwnPropertyDescriptor(ｔｅｓｔTwo, 'name');\n    // output: {value: \"testTwo\", writable: false, enumerable: false, configurable: true} \n```\n\n所有原声的只可以delete，之后testOne.name输出为＇＇，不能修改.\n\n```\n    testTwo.constructor.names = 'c';\n    testTwo.names\n    // output: c\n    \n    Object,getOwnPropertyDescriptor(testTwo, 'names');\n    // output: {value: \"c\", writable: true, enumerable: true, configurable: true}\n```\n\n非原生的属性，添加之后可以修改,所以在执行new操作时，将tetTwo的指针指向了\btestTwo.constructor\n\t\n```\n    testOne.prototype.newOne = '5';\n    testTwo.newOne\n    // output: '5'\n    testTwo.newOne = '6';\n    testTwo.newOne\n    // output: '6'\n    testTwo\n    // output: \n        bbb:\"444\"\n        __proto__:\tObject\n            bbb: \"2\"\n            constructor: d()\n            ＿_proto__: Object\n```\n\nnewOne　屏蔽掉了原属性，因为将怎么testOne的指针指＿proto＿\n\n```\n    Object.keys(testTwo);\n    // output: ['bbb']    \n```\n\n这也是为什么Object.keys只出现bbb，因为＿proto＿，constructor不可枚举.\n\n\n```\n    const name(){};\n    name.prototype;\n    // output: constructor: name()\n                __proto__:Object               \n    const nameTwo(){};\n    nameTwo.prototype = {};\n    nameTwo.prototype;\n    // output: __proto__:Object\n```\n这也切断了与原型之间的联系，constructor变成了＿ｐｒｏｔｏ＿的属性\n\n\n```\n    const nameThree(){};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: { writable: true, enumerable: false, configurable: true }\n    nameThree.prototype = { constructor: nameThree};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: {writable: true, enumerable: true, configurable: true}\n```\n\n操作prototype会使，constructor消失，如果手动改变，这会使constructor种的enumerable变成true（即可枚举）\t","tags":["JavaScript"],"categories":["编程语言"]}]