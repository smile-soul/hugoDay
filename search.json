[{"title":"个人插件","url":"/2017/09/29/个人插件库-md/","content":"\n### Alfred的相关插件\n---\n* AboutThisMac: 列出系统相关配置信息\n* colors: 前端选取颜色列表，查询颜色rgb,hsl值等\n* Hash: 文件hash加密\n* KD: 快递快速查询\n* npm: npmio快速查询\n* RMB: 人民币数汉转换\n* shanbay: 扇贝中英文翻译\n* StackOverflow: stackoverflow快速查询\n* YD: 有道词典中英文翻译\n* YDI: 有道词典加强中英文翻译\n---\n### Chrome的相关插件\n\n---\n* 1Password: 密码管理\n* Advanced REST client: 正则表达式\n* Checker Plus for Gmail: Gmail邮箱\n* Chrono Download Manager: 下载器\n* Hide Files on GitHub: 隐藏Github的所有只有扩展名文件\n* History Trends: chrome历史浏览记录\n* IcoMoon: icoMoon网站\n* Insight.io for Github: github的tree推荐\n* Isometric Contributions: github的commit大楼\n* JavaScript Errors Notifier: JavaScript的浏览器报错\n* JSON Formatter: JSON格式自动切换\n* OneTab: 所有Tab页面集合一个Tab页面\n* OctoLinker: github代码包连接跳转\n* npmhub: npmhub包自动跳转\n* Pocket: plan记录\n* Postman: api请求测试\n* Proxy SwitchyOmega: 翻墙代理必备\n* Quick Javascript Switcher: 快速关闭JavaScript脚本使用\n* Scratch JS: 浏览器内置coderunnner\n* Speedtest by Ookla: 网页测速\n* Tampermonkey: 插件大合集搜索网站,可查找需要的插件\n* The Great Suspender: 自动挂载长期未使用的页面，节省内存空间\n* Vimium: 网页版vim\n* WhatFont: 查看当前网页标签内字体\n* ZenHub for GitHub: Github中的board\n\n---\n\n### VScode 插件合集\n\n---\n* Auto Rename Tag: HTML自动修改标签\n* Auto-Open Markdwon Preview: 编写markdown必备，自动开启Preview模式\n* AutoFileName: 文件名字自动提示\n* Can I Use: CSS兼容性显示\n* Code Runner: 代码运行环境\n* Color Hightlight: 颜色自动显色\n* Docker: Docker管理\n* Document this: 自动添加注释\n* EditorConfig for VSCode: 文件格式自动整理\n* Git History: git log记录查看\n* Git lens: 代码编写提交历史查看\n* JavaScript code snippets: JavaScript的snippets\n* kubernetes Support: kubernetes的配置文件\n* Nodejs Modules Intellisense: node内置模块包提示\n* npm: npm包的提示操作，记录哪些包未使用或者未安装\n* npm Dependency: 可自动更新npm包的相关版本\n* Project Manager: 项目管理\n* Setting Sync: 插件同步管理\n* vscode-icons: vscode的Icon图标\n\n---\n* 希望各位大佬来补充，相互交流，扩充插件库\n\n\n- Github地址: https://github.com/smile-soul\n- 个人Blog: http://www.smilesoul.cn/\n\n","tags":["tools"],"categories":["开发工具"]},{"title":"前端构建工具介绍","url":"/2017/08/07/前端构建工具介绍/","content":"\n### Grunt and Gulp(构建工具)\n-----\n#### 两者优缺点对比\n\n1. Grunt 有一个完善的社区，插件丰富. 它简单易学。（大约4000+\b，\b将近Gulp两倍);\n2. Grunt 是基于文件流，Gulp是基于管道流。\n3. Grunt 的缺点\n    * 但插件很难遵守单一责任原则。比如说要对处理后的文件进行更名操作，你可能使用的是 uglify 插件，也有可能使用的是 concat 插件（取决于工作流的最后一个环节是谁）。对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在个人看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个独立的组（Files），任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。\n    * 用插件做一些本来不需要插件来做的事情。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 karma start）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。\n    * 试图用配置文件完成所有事，结果就是混乱不堪。规模较大，构建／分发／部署流程较为复杂的项目，其 Gruntfile有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”。 \n    * 落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后。\n\nGruntfile.js范例\n```\nmodule.exports = function(grunt) {\n    grunt.initConfig({\n        concat: {\n            'dist/all.js': ['src/*.js']\n        },\n        uglify: {\n            'dist/all.min.js': ['dist/all.js']\n        },\n        jshint: {\n            files: ['gruntfile.js', 'src/*.js']\n        },\n        watch: {\n            files: ['gruntfile.js', 'src/*.js'],\n            tasks: ['jshint', 'concat', 'uglify']\n        }\n    });\n    // Load Our Plugins\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-concat');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    // Register Default Task\n    grunt.registerTask('default', ['jshint', 'concat', 'uglify']);\n};\n```\nGulpfile.js范例\n```\nconst gulp = require('gulp');\nconst jshint = require('gulp-jshint');\nconst concat = require('gulp-concat');\nconst uglify = require('gulp-uglify');\nconst rename = require('gulp-rename');\n  \n// 语法检查\ngulp.task('jshint', function () {\n    return gulp.src('src/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n  \n// 合并文件之后压缩代码\ngulp.task('minify', function (){\n     return gulp.src('src/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('dist'))\n        .pipe(uglify())\n        .pipe(rename('all.min.js'))\n        .pipe(gulp.dest('dist'));\n});\n  \n// 监视文件的变化\ngulp.task('watch', function () {\n    gulp.watch('src/*.js', ['jshint', 'minify']);\n});\n  \n// 注册缺省任务\ngulp.task('default', ['jshint', 'minify', 'watch']);\n```\n附录\nGulp插件库:z http://gulpjs.com/plugins\nGulp API: https://github.com/gulpjs/gulp/blob/master/docs/API.md\nGrunt API: https://gruntjs.com/api/grunt\n\n### Browserify and Webpack(模块化工具)\n1. seajs / require : 是一种在线\"编译\" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module , 也就实现了模块化。\n2. browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先它是预编译的，不需要在浏览器中加载解释器。Browserify与WebPack的功能类似；它也是基于文件流的，相较于WebPack，Browserify能够对处理过程做更精细的控制，而WebPack相对更加‘黑盒’。还有就是WebPack的生态要比Browserify好得多。\n\n### Npm, yarn, bower\n1. npm安装依赖包的时候，会将包的不同版本放在合适的地方，从而，可以在想要的地方加载想要的版本。但是，这样对于前端来说，就是噩梦了(比如有两个版本的jQuery，或者两个版本的Bootstrap)。\n2. npm是为JavaScript服务的包管理器，目前的仓库中大多数都是Node.js包，使用Browserify进行适配之后，某些模块可以在客户端运行，但还有很多仍然不行。\n3. npm会创建一个树形的依赖关系，而bower创建的是扁平化的层级依赖关系。\n4. 树形的依赖关系的意思就是每一个包都可以有他自己的依赖包。在服务器上，这样做很好，并不用太关心空间不够用什么的。但是，在前端，这样就显得很不友好了，想象一下一个网站同时加载了三个不同版本的jQuery。\n5. bower安装的目录结构是扁平的。相互依赖的包会被放到同一级目录下。由于目录扁平化，所以，发生版本冲突的时候，需要人工解决。这样，任何人得到这个项目，安装的包的版本都是相同的了。\n\n### Yeoman\n\n1.Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。\n\n附录\n创建Yeoman: http://www.yowebapp.com/authoring/index.html","tags":["framework"],"categories":["前端构建"]},{"title":"Yeoman使用和编写","url":"/2017/08/04/Yeoman使用和编写/","tags":["JavaScript"],"categories":["编程语言"]},{"title":"原型函数Construction解析","url":"/2016/07/06/JavaScript-constructor/","content":"\n### 理解原型之间的关系\n\n```\n    testOne() {};\n    testOne.prototype\n    // Object {\n            constructor: a()\n                    arguments: null\n                    caller: null\n                    length: 0\n                    name:\"a\"\n                    prototype: Object\n                    __proto__: ()\n                    <function scope>\n                    //注意层级关系\n            __proto__: Object\n        }\n        \n        \n    testOne.length\n    // output: 0\n    \n    \n    testOne.prototype.name = '2';\n    testOne.name\n    // output: 'a';\n```\n**注意**: 这里输出为'a'，而不是２，它会去查constructor里面的name，因为prototype.constructor是会指回testOne，如果要获取＇２＇，只能testOne.prototype.name来获取.\n\t\n```\t\t\t\n    const testTwo = new testOne();\n    testTwo.prototype\n    //output: undefined\n```\n\n**注意**: 每创建一个函数才会创建它的prototype对象，使用new，不会创建prototype对象\n    \n```   \n    testTwo.constructor\n    //output: testOne(){}\n    \n    testTwo.constructor.name = 'b';\n    testTwo.name\n    // output: testTwo\n    \n    Object.getOwnPropertyDescriptor(ｔｅｓｔTwo, 'name');\n    // output: {value: \"testTwo\", writable: false, enumerable: false, configurable: true} \n```\n\n所有原声的只可以delete，之后testOne.name输出为＇＇，不能修改.\n\n```\n    testTwo.constructor.names = 'c';\n    testTwo.names\n    // output: c\n    \n    Object,getOwnPropertyDescriptor(testTwo, 'names');\n    // output: {value: \"c\", writable: true, enumerable: true, configurable: true}\n```\n\n非原生的属性，添加之后可以修改,所以在执行new操作时，将tetTwo的指针指向了\btestTwo.constructor\n\t\n```\n    testOne.prototype.newOne = '5';\n    testTwo.newOne\n    // output: '5'\n    testTwo.newOne = '6';\n    testTwo.newOne\n    // output: '6'\n    testTwo\n    // output: \n        bbb:\"444\"\n        __proto__:\tObject\n            bbb: \"2\"\n            constructor: d()\n            ＿_proto__: Object\n```\n\nnewOne　屏蔽掉了原属性，因为将怎么testOne的指针指＿proto＿\n\n```\n    Object.keys(testTwo);\n    // output: ['bbb']    \n```\n\n这也是为什么Object.keys只出现bbb，因为＿proto＿，constructor不可枚举.\n\n\n```\n    const name(){};\n    name.prototype;\n    // output: constructor: name()\n                __proto__:Object               \n    const nameTwo(){};\n    nameTwo.prototype = {};\n    nameTwo.prototype;\n    // output: __proto__:Object\n```\n这也切断了与原型之间的联系，constructor变成了＿ｐｒｏｔｏ＿的属性\n\n\n```\n    const nameThree(){};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: { writable: true, enumerable: false, configurable: true }\n    nameThree.prototype = { constructor: nameThree};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: {writable: true, enumerable: true, configurable: true}\n```\n\n操作prototype会使，constructor消失，如果手动改变，这会使constructor种的enumerable变成true（即可枚举）\t","tags":["JavaScript"],"categories":["编程语言"]}]