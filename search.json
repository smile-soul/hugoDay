[{"title":"Web最佳实践阅读总结(1)","url":"/2017/10/05/Web最佳实践阅读总结-1/","content":"\n### 介绍\n----\n最近开始刷一些书和题,此系列是介绍在读`Web最佳实践`的一些收获和体会。\n![](http://ou42j47mq.bkt.clouddn.com/2017-10-05-webbest.jpg)\n---\n##### web前端发展现状\n* 存在问题：\n    * 代码组织混乱\n    * 代码格式的问题突出\n    * 页面布局随意\n    * 网站整体性能差，没有意识到应用诸如缓存，动态加载，脚本压缩，图片压缩等提高性能技术\n* 推荐做法：\n    * 压缩样式表和脚本文件\n    * 减少HTTP请求次数\n    * 简洁和符合W3C标准的HTML和CSS代码能减少浏览器解析的时间，加快渲染过程\n    * 页面请求数量越少，相对页面的加载速度更快\n    * 在JS代码中选择性能更好的实现方案，如延迟加载，动态加载等技术;\n* 延迟加载\n        <script type=”text/javascript” src=”\" id=”my”></script> \n        <script type=”text/javascript”> \n        setTimeout(“document.getElementById(‘my').src='include/php100.php'; “,3000);//延时3秒 \n        </script> \n* 最后加载\n    * 引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码，所以可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度\n* 动态加载\n        <scrīpt src='' id=\"s1\"></scrīpt> \n        <scrīpt language=\"javascrīpt\"> \n        s1.src=\"test.js\" \n        </scrīpt> \n* ##### 前端代码重构\n*  删除无用代码，精简代码（不起作用的CSS样式和废弃的JavaScript函数）\n*  前端代码规范化，把CSS代码放到独立的文件中，在JS定义局部变量，把部分全局变量改变成局部变量\n*  前端代码模块化，引入面向对象的思想来重构JavaScript代码，进一步明确公有接口和私有接口\n*  提高页面性能：\n    * 将部分不影响首页展示的JS文件延迟到页面的加载后加载\n    * 删除页面中初始隐藏的区域，改为通过JS按需动态生成\n    * 页面中的部分图片延迟加载\n    * 调整CSS和JS文件引用顺序，即CSS在前，JS在后\n    * 给静态文件设置缓存，使用CSS Sprite，合并背景图\n    * 合并和压缩发布后的CSS和JS代码模块\n*  前端重构最佳实践\n    * 重构前一定要预测风险，最好先完善自动化测试代码\n    * 重构的目的和范围要明确，提高代码的可维护性，可读性和性能\n    * 最好先易后难，循序渐进。先修改诸如命名，格式等不涉及具体逻辑的内容\n    * 重构过程中要持续测试，在多个浏览器测试，确保重构的部分功能正确。切记大量重构后再进行测试，因为大量重构后基本很难记得重构的逻辑，也可能遗漏部分测试用例\n    * 性能提升，先进行检测网站的整体性能并量化，找出性能瓶颈。重构过程中要持续监控性能，并进行对比\n* ##### 前端框架的使用\n*  项目需求\n    * 调查项目是否需要AJAX操作\n    * 是否需要模块化\n    * 数据传输格式JSON或者XML\n    * 需要支持的浏览器\n    * 移动还是普通网站\n    * 需要的UI模块（模态窗口，滑块控件，进度条，提示框，分割框，幻灯显示，自动填充）\n*  项目的特点\n*  框架的特点\n* ##### HTML5兼容\n*  编写高质量，标准的HTML（标准校验工具，JSLint）\n*  明确浏览器支持范围\n    * Chrome和Safari（Webkit内核）IE Tester（IE兼容测试工具）IE9(IE DevToolbar)\n*  避免浏览器兼容性的问题\n    * 先考虑更改方案，使用没有兼容问题的代码\n    * 考虑如何兼容的问题\n    * 兼容IE，使用IE特有的条件表达式\n    * 让兼容的代码独立，提高代码的可维护性\n*  HTML5新特性\n    * 新标签的兼容，CSS3的兼容，新增的API（使用html5shiv框架）\n    * CSS3本身不支持，会直接忽略\n    * 新增加的接口的使用，必须添加条件判断（Modernizr）\n    * 多看Can I use\n* ##### web性能分析\n*  YSlow，pagespeed\n    * 基于不同的规则评定网站整体性能评分\n    * 给出提高网页性能的建议\n    * 统计页面加载的组件\n    * 页面的统计信息视图\n    * 相关性能分析工具集：Smush.it\n*  Chrome开发工具中有Network，Timeline，Profiles，Aidits\n    * Network中可以查看各资源请求和下载所用的时间\n    * Timeline可以查看网页渲染和交互过程中个步骤所花费的时间，从资源到JS的解析执行，样式的应用和绘制\n    * Profiles中可以查看网页的CPU及内存占有情况报告\n    * Audits中提供了各种资源和配置优化的建议和未使用CSS规则的列表\n* ##### 代码和资源的压缩和合并\n*  加快代码和资源文件传输的方式\n    * CDN分发\n    * 缓存\n    * 压缩代码和资源文件（最优）\n    * Gzip算法（压缩，header可以检查是否开启）\n    * JS压缩（UglifyJS压缩和优化，YUI Compressor 仅压缩，Closure Compiler压缩和优化）\n    * CSS(CSS Compressor,YUI Compressor)\n    * HTML(HtmlCompressor使用时仔细调查和测试，避免压缩工具和破坏)\n    * 图片资源压缩（TinyPNG，JPEGmini，ImageOptim）\n    * 使用ANT（构建代码和资源压缩任务）\n    * grunt压缩（js：grunt-contrib-uglify，css：grunt-contrib-cssmin，图片：grunt-contrib-imagemin）\n* ##### 前端代码规范\n*  HTML 标签和属性都小写，属性双引号闭合\n*  层级为4个空格\n*  添加必要的注释\n*  class去父辈为前缀\n*  相同模块放在一起，不同模块进行分类\n*  JS首字母小写，其他字母大写\n*  公有接口首字母大写，私有接口首字母小写\n*  使用带括号包含逻辑块，字符串用单引号标记\n*  函数参数逗号后面加一个空格\n*  添加分号，推荐使用//，不使用/\\* \\*/ \n\n","tags":["JavaScript"],"categories":["编程语言"]},{"title":"变量和方法","url":"/2017/09/29/变量和方法/","content":"### 变量和方法\n---\n#### 类型\n * js的变量中只用primitive类型和object类型\n * 平时使用的字符串应该是primitive类型，应该是not an object and has no methods\n\n\t```\n\t\tconst str = 'hello';\n\t\tconsole.log(str.charAt(0));\n\t\t// output: h\n\t\tObject.prototype.toString.call(str)\n\t\t// output: [object String]\t\n\t```\n * 出现这样的情况，因为str.charAt时候，String(primitive)转换成了String(object)类型在[ECMAScript Language Specification&8.7.1](http://www.ecma-international.org/ecma-262/5.1/#sec-8.7) 明确指出变量类型的转换\n * 所以primitive类型的value是immutable的，而variable是mutable的，对与primitive类型的变量，为其赋值，本质上就是让变量指向新的内存。\n\n---\n\n#### lodash相关技巧和实例\n  * N次循环技巧\n \t\n\t```\n    for(let i = 0; i < 5; i++) {\n        // ...\n    }\n    Array.apply(null, Array(5)).forEach(() => {\n        // ...\n        });\n    _.times(5, () => {\n        // ...\n        };\n    ```\n\n  * 深层次查找属性\n  \t\n    ```\n        const ownerArr = [{\n    \t\"owner\": \"Colin\",\n      \t\"pets\": [{\"name\":\"dog1\"}, {\"name\": \"dog2\"}]\n        }, {\n            \"owner\": \"John\",\n            \"pets\": [{\"name\":\"dog3\"}, {\"name\": \"dog4\"}]\n        }];\n\n        ownerArr.map(owner => {\n            return owner.pets[0].name;\n            });\n\n        _.map(ownerArr, 'pets[0].name');\n    ```\n  \t\n  * 数组独立\n  \t\n    ```\n        Array.apply(null, Array(6)).map( (item, index) => {\n        return \"ball_\" + index;\n        });\n\n        _.times(6, _.uniqueId.bind(null, 'ball_'));\n\n        _.times(6, _.partial(_.uniqueId, 'ball_'));\n        // output: [ball_0, ball_1, ball_2, ball_3, ball_4, ball_5]\n    ```\n  * 对象扩展(可以直接用Object.assgin(), 底层一样的实现）\n  \t\n    ```\n         Object.prototype.extend = obj => {\n    \tfor (let i in obj) {\n      \t\tif (obj.hasOwnProperty(i)) {\n        \t\tthis[i] = obj[i];\n      \t\t}\n    \t}\n    };\n        const objA = {\"name\": \"colin\", \"car\": \"suzuki\"};\n        const objB = {\"name\": \"james\", \"age\": 17};\n\n        objA.extend(objB);\n        console.log(objA); \n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        _.assign(objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        // ES6\n        Objetct.assign({}, objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n        //_.assign 是浅拷贝，所以会覆盖name\n    ```\n  * 补充作用域：\n    \n    ```\n    const test = '1';\n    testOne() {\n        return testTwo{\n            cosole.log(test);\n        };\n        const test = '2';\n    }\n    testOne()();\n    // output: undefined \n    \n    \n    const test = '1';\n    testOne() {\n        return testTwo{\n            console.log(test);\n        };\n        test = '2';\n    }\n    // output: 1;\n    ```\n    因为重新定义了const，他在搜索作用域时候，会自上到下搜索**声明**的变量，如果没有声明，查找才会进去下一层，此处输出undefined，因为在testOne（）里面const之前就使用了test，所以就输出了undefined,而在第二个例子里面没有声明test，所以他就跳转出去，去下一层寻找test，即输出为1\n  \t\n * 作用域提升\n \n\t```\n        const a = 1;\n        b(){\n            const a = b = 2;\n        }\n        console.log(a, b);\n        // 抛出异常，因为ｂ没有定义\n        \n        b();\n        console.log(a, b);\n        //output: 1,2;\n        // const a = b = 2 等价于　在全局声明const b = 2; 内部声明const a = b;因为=运算符是重右像左运算的\n    ```\n---\n#### 附录\n * [MDN连接文档](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n * [lodash相关技巧](http://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting)\n * [10个ES6可以代替lodash的方法](https://www.sitepoint.com/lodash-features-replace-es6/)","tags":["JavaScript"],"categories":["编程语言"]},{"title":"Object","url":"/2017/09/29/object/","content":"\n### Object属性：\n---\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. writable：true\n\t* 能否修改属性的值\n4. value：undefined\n\t* 包含这个属性的数据\n5. Object.defineProperty(obj, 'name', {}) (ES5)\n\n\t```\n\tObject.defineProperty(obj, 'key', {\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t\twritable: false,\n\t\tvalue: 'static'\n\t});\n\t```\n6. Object.defineProperty(obj, {})\n\t\n\t```\n\tconst obj = {};\n\tObject.defineProperties(obj, {\n\t\t\"property1\": {\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t},\t\n\t\t\"property2\": {\n\t\t\tvalue: \"Hello\",\n\t\t\twritable: false\n\t\t\t}\n\t\t});\t\n\t\n\tcosnt obj = {};\n\tObject.defineProperty(obj, 'key', {});\n\tObject.getOwnPropertyDescriptor(obj, 'key');\t\t\t\n\t// output: Object {\n\t\tvalue: undefined, \n\t\twritable: false, \n\t\tenumerable: false, \n\t\tconfigurable: false}\n\t\t\n\t// 注意：在这样定义时候，非定义的configurable等为false\n\tobj.name = 'lty';\n\t//这样定义的时候，configurable等才为true\n\t\n\t```\n7. 一旦把configurable设为false，就不能设回成true，即一切配置都不可使用。\n\n---\n### 访问器属性\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. get: undefined\n\t* 读取数据时候调用\n4. set：undefined\n\t* 写入属性时候调用\n5. 访问器属性不能直接定义，只能使用Object.defineProperty()来定义\n6. 因为 primitive 是 immutable 的,所以赋值分配新的内存,即为写入\n\n\t```\n\t\tconst book = {\n\t\t\t_year: 2004,\n\t\t\tedition: 1,\n\t\t}\n\t\tObject.defineProperty(book, 'year', {\n\t\t\tget: () => this._year,\n\t\t\tset: newline => {\n\t\t\t\tif\t(newline > 2000) {\n\t\t\t\t\tthis._year = newline;\n\t\t\t\t\tthis.edition += 1;\n\t\t\t\t};\n\t\t\t},\n\t\t})\n\t\tbook.year = 2005;\n\t\tconsole.log(edition);\n\t\t// output: 2\n\t```\n7. 浏览器中一般是使用_defineGetter_和_defineSetter_来代替\t","tags":["JavaScript"],"categories":["编程语言"]},{"title":"个人插件","url":"/2017/09/29/个人插件/","content":"\n### Alfred的相关插件\n---\n* AboutThisMac: 列出系统相关配置信息\n* colors: 前端选取颜色列表，查询颜色rgb,hsl值等\n* Hash: 文件hash加密\n* KD: 快递快速查询\n* npm: npmio快速查询\n* RMB: 人民币数汉转换\n* shanbay: 扇贝中英文翻译\n* StackOverflow: stackoverflow快速查询\n* YD: 有道词典中英文翻译\n* YDI: 有道词典加强中英文翻译\n---\n### Chrome的相关插件\n\n---\n* 1Password: 密码管理\n* Advanced REST client: 正则表达式\n* Checker Plus for Gmail: Gmail邮箱\n* Chrono Download Manager: 下载器\n* Hide Files on GitHub: 隐藏Github的所有只有扩展名文件\n* History Trends: chrome历史浏览记录\n* IcoMoon: icoMoon网站\n* Insight.io for Github: github的tree推荐\n* Isometric Contributions: github的commit大楼\n* JavaScript Errors Notifier: JavaScript的浏览器报错\n* JSON Formatter: JSON格式自动切换\n* OneTab: 所有Tab页面集合一个Tab页面\n* OctoLinker: github代码包连接跳转\n* npmhub: npmhub包自动跳转\n* Pocket: plan记录\n* Postman: api请求测试\n* Proxy SwitchyOmega: 翻墙代理必备\n* Quick Javascript Switcher: 快速关闭JavaScript脚本使用\n* Scratch JS: 浏览器内置coderunnner\n* Speedtest by Ookla: 网页测速\n* Tampermonkey: 插件大合集搜索网站,可查找需要的插件\n* The Great Suspender: 自动挂载长期未使用的页面，节省内存空间\n* Vimium: 网页版vim\n* WhatFont: 查看当前网页标签内字体\n* ZenHub for GitHub: Github中的board\n\n---\n\n### VScode 插件合集\n\n---\n* Auto Rename Tag: HTML自动修改标签\n* Auto-Open Markdwon Preview: 编写markdown必备，自动开启Preview模式\n* AutoFileName: 文件名字自动提示\n* Can I Use: CSS兼容性显示\n* Code Runner: 代码运行环境\n* Color Hightlight: 颜色自动显色\n* Docker: Docker管理\n* Document this: 自动添加注释\n* EditorConfig for VSCode: 文件格式自动整理\n* Git History: git log记录查看\n* Git lens: 代码编写提交历史查看\n* JavaScript code snippets: JavaScript的snippets\n* kubernetes Support: kubernetes的配置文件\n* Nodejs Modules Intellisense: node内置模块包提示\n* npm: npm包的提示操作，记录哪些包未使用或者未安装\n* npm Dependency: 可自动更新npm包的相关版本\n* Project Manager: 项目管理\n* Setting Sync: 插件同步管理\n* vscode-icons: vscode的Icon图标\n\n---\n* 希望各位大佬来补充，相互交流，扩充插件库\n\n\n- Github地址: https://github.com/smile-soul\n- 个人Blog: http://www.smilesoul.cn/\n\n","tags":["tools"],"categories":["开发工具"]},{"title":"前端构建工具介绍","url":"/2017/08/07/前端构建工具介绍/","content":"\n### Grunt and Gulp(构建工具)\n-----\n#### 两者优缺点对比\n\n1. Grunt 有一个完善的社区，插件丰富. 它简单易学。（大约4000+\b，\b将近Gulp两倍);\n2. Grunt 是基于文件流，Gulp是基于管道流。\n3. Grunt 的缺点\n    * 但插件很难遵守单一责任原则。比如说要对处理后的文件进行更名操作，你可能使用的是 uglify 插件，也有可能使用的是 concat 插件（取决于工作流的最后一个环节是谁）。对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在个人看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个独立的组（Files），任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。\n    * 用插件做一些本来不需要插件来做的事情。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 karma start）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。\n    * 试图用配置文件完成所有事，结果就是混乱不堪。规模较大，构建／分发／部署流程较为复杂的项目，其 Gruntfile有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”。 \n    * 落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后。\n\nGruntfile.js范例\n```\nmodule.exports = function(grunt) {\n    grunt.initConfig({\n        concat: {\n            'dist/all.js': ['src/*.js']\n        },\n        uglify: {\n            'dist/all.min.js': ['dist/all.js']\n        },\n        jshint: {\n            files: ['gruntfile.js', 'src/*.js']\n        },\n        watch: {\n            files: ['gruntfile.js', 'src/*.js'],\n            tasks: ['jshint', 'concat', 'uglify']\n        }\n    });\n    // Load Our Plugins\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-concat');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    // Register Default Task\n    grunt.registerTask('default', ['jshint', 'concat', 'uglify']);\n};\n```\nGulpfile.js范例\n```\nconst gulp = require('gulp');\nconst jshint = require('gulp-jshint');\nconst concat = require('gulp-concat');\nconst uglify = require('gulp-uglify');\nconst rename = require('gulp-rename');\n  \n// 语法检查\ngulp.task('jshint', function () {\n    return gulp.src('src/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n  \n// 合并文件之后压缩代码\ngulp.task('minify', function (){\n     return gulp.src('src/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('dist'))\n        .pipe(uglify())\n        .pipe(rename('all.min.js'))\n        .pipe(gulp.dest('dist'));\n});\n  \n// 监视文件的变化\ngulp.task('watch', function () {\n    gulp.watch('src/*.js', ['jshint', 'minify']);\n});\n  \n// 注册缺省任务\ngulp.task('default', ['jshint', 'minify', 'watch']);\n```\n附录\n* Gulp插件库: http://gulpjs.com/plugins\n* Gulp API: https://github.com/gulpjs/gulp/blob/master/docs/API.md\n* Grunt API: https://gruntjs.com/api/grunt\n\n### Browserify and Webpack(模块化工具)\n1. seajs / requirejs : 是一种在线\"编译\" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module , 也就实现了模块化。\n2. browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先它是预编译的，不需要在浏览器中加载解释器。它也是基于文件流的，相较于WebPack，Browserify能够对处理过程做更精细的控制，而WebPack相对更加‘黑盒’。还有就是WebPack的生态要比Browserify好得多。\n\n### Npm, yarn, bower\n1. npm安装依赖包的时候，会将包的不同版本放在合适的地方，从而，可以在想要的地方加载想要的版本。但是，这样对于前端来说，就是噩梦了(比如有两个版本的jQuery，或者两个版本的Bootstrap)。\n2. npm是为JavaScript服务的包管理器，目前的仓库中大多数都是Node.js包，使用Browserify进行适配之后，某些模块可以在客户端运行，但还有很多仍然不行。\n3. npm会创建一个树形的依赖关系，而bower创建的是扁平化的层级依赖关系。\n4. 树形的依赖关系的意思就是每一个包都可以有他自己的依赖包。在服务器上，这样做很好，并不用太关心空间不够用什么的。但是，在前端，这样就显得很不友好了，想象一下一个网站同时加载了三个不同版本的jQuery。\n5. bower安装的目录结构是扁平的。相互依赖的包会被放到同一级目录下。由于目录扁平化，所以，发生版本冲突的时候，需要人工解决。这样，任何人得到这个项目，安装的包的版本都是相同的了。\n\n### Yeoman\n1. Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。","tags":["framework"],"categories":["前端构建"]},{"title":"原型函数Construction解析","url":"/2016/07/06/JavaScript-constructor/","content":"\n### 理解原型之间的关系\n\n```\n    testOne() {};\n    testOne.prototype\n    // Object {\n            constructor: a()\n                    arguments: null\n                    caller: null\n                    length: 0\n                    name:\"a\"\n                    prototype: Object\n                    __proto__: ()\n                    <function scope>\n                    //注意层级关系\n            __proto__: Object\n        }\n        \n        \n    testOne.length\n    // output: 0\n    \n    \n    testOne.prototype.name = '2';\n    testOne.name\n    // output: 'a';\n```\n**注意**: 这里输出为'a'，而不是２，它会去查constructor里面的name，因为prototype.constructor是会指回testOne，如果要获取＇２＇，只能testOne.prototype.name来获取.\n\t\n```\t\t\t\n    const testTwo = new testOne();\n    testTwo.prototype\n    //output: undefined\n```\n\n**注意**: 每创建一个函数才会创建它的prototype对象，使用new，不会创建prototype对象\n    \n```   \n    testTwo.constructor\n    //output: testOne(){}\n    \n    testTwo.constructor.name = 'b';\n    testTwo.name\n    // output: testTwo\n    \n    Object.getOwnPropertyDescriptor(ｔｅｓｔTwo, 'name');\n    // output: {value: \"testTwo\", writable: false, enumerable: false, configurable: true} \n```\n\n所有原声的只可以delete，之后testOne.name输出为＇＇，不能修改.\n\n```\n    testTwo.constructor.names = 'c';\n    testTwo.names\n    // output: c\n    \n    Object,getOwnPropertyDescriptor(testTwo, 'names');\n    // output: {value: \"c\", writable: true, enumerable: true, configurable: true}\n```\n\n非原生的属性，添加之后可以修改,所以在执行new操作时，将tetTwo的指针指向了\btestTwo.constructor\n\t\n```\n    testOne.prototype.newOne = '5';\n    testTwo.newOne\n    // output: '5'\n    testTwo.newOne = '6';\n    testTwo.newOne\n    // output: '6'\n    testTwo\n    // output: \n        bbb:\"444\"\n        __proto__:\tObject\n            bbb: \"2\"\n            constructor: d()\n            ＿_proto__: Object\n```\n\nnewOne　屏蔽掉了原属性，因为将怎么testOne的指针指＿proto＿\n\n```\n    Object.keys(testTwo);\n    // output: ['bbb']    \n```\n\n这也是为什么Object.keys只出现bbb，因为＿proto＿，constructor不可枚举.\n\n\n```\n    const name(){};\n    name.prototype;\n    // output: constructor: name()\n                __proto__:Object               \n    const nameTwo(){};\n    nameTwo.prototype = {};\n    nameTwo.prototype;\n    // output: __proto__:Object\n```\n这也切断了与原型之间的联系，constructor变成了＿ｐｒｏｔｏ＿的属性\n\n\n```\n    const nameThree(){};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: { writable: true, enumerable: false, configurable: true }\n    nameThree.prototype = { constructor: nameThree};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: {writable: true, enumerable: true, configurable: true}\n```\n\n操作prototype会使，constructor消失，如果手动改变，这会使constructor种的enumerable变成true（即可枚举）\t","tags":["JavaScript"],"categories":["编程语言"]}]