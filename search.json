[{"title":"变量和方法","url":"/2017/09/29/变量和方法/","content":"\n### 变量和方法\n---\n#### 类型\n * js的变量中只用primitive类型和object类型\n * 平时使用的字符串应该是primitive类型，应该是not an object and has no methods\n\n\t```\n\t\tconst str = 'hello';\n\t\tconsole.log(str.charAt(0));\n\t\t// output: h\n\t\tObject.prototype.toString.call(str)\n\t\t// output: [object String]\t\n\t```\n * 出现这样的情况，因为str.charAt时候，String(primitive)转换成了String(object)类型在[ECMAScript Language Specification&8.7.1](http://www.ecma-international.org/ecma-262/5.1/#sec-8.7) 明确指出变量类型的转换\n * 所以primitive类型的value是immutable的，而variable是mutable的，对与primitive类型的变量，为其赋值，本质上就是让变量指向新的内存。\n\n---\n\n#### lodash相关技巧和实例\n  * N次循环技巧\n \t\n\t```\n    for(let i = 0; i < 5; i++) {\n        // ...\n    }\n    Array.apply(null, Array(5)).forEach(() => {\n        // ...\n        });\n    _.times(5, () => {\n        // ...\n        };\n    ```\n\n  * 深层次查找属性\n  \t\n    ```\n        const ownerArr = [{\n    \t\"owner\": \"Colin\",\n      \t\"pets\": [{\"name\":\"dog1\"}, {\"name\": \"dog2\"}]\n        }, {\n            \"owner\": \"John\",\n            \"pets\": [{\"name\":\"dog3\"}, {\"name\": \"dog4\"}]\n        }];\n\n        ownerArr.map(owner => {\n            return owner.pets[0].name;\n            });\n\n        _.map(ownerArr, 'pets[0].name');\n    ```\n  \t\n  * 数组独立\n  \t\n    ```\n        Array.apply(null, Array(6)).map( (item, index) => {\n        return \"ball_\" + index;\n        });\n\n        _.times(6, _.uniqueId.bind(null, 'ball_'));\n\n        _.times(6, _.partial(_.uniqueId, 'ball_'));\n        // output: [ball_0, ball_1, ball_2, ball_3, ball_4, ball_5]\n    ```\n  * 对象扩展(可以直接用Object.assgin(), 底层一样的实现）\n  \t\n    ```\n         Object.prototype.extend = obj => {\n    \tfor (let i in obj) {\n      \t\tif (obj.hasOwnProperty(i)) {\n        \t\tthis[i] = obj[i];\n      \t\t}\n    \t}\n    };\n        const objA = {\"name\": \"colin\", \"car\": \"suzuki\"};\n        const objB = {\"name\": \"james\", \"age\": 17};\n\n        objA.extend(objB);\n        console.log(objA); \n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        _.assign(objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        // ES6\n        Objetct.assign({}, objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n        //_.assign 是浅拷贝，所以会覆盖name\n    ```\n  * 补充作用域：\n    \n    ```\n    const test = '1';\n    testOne() {\n        return testTwo{\n            cosole.log(test);\n        };\n        const test = '2';\n    }\n    testOne()();\n    // output: undefined \n    \n    \n    const test = '1';\n    testOne() {\n        return testTwo{\n            console.log(test);\n        };\n        test = '2';\n    }\n    // output: 1;\n    ```\n    因为重新定义了const，他在搜索作用域时候，会自上到下搜索**声明**的变量，如果没有声明，查找才会进去下一层，此处输出undefined，因为在testOne（）里面const之前就使用了test，所以就输出了undefined,而在第二个例子里面没有声明test，所以他就跳转出去，去下一层寻找test，即输出为1\n  \t\n * 作用域提升\n \n\t```\n        const a = 1;\n        b(){\n            const a = b = 2;\n        }\n        console.log(a, b);\n        // 抛出异常，因为ｂ没有定义\n        \n        b();\n        console.log(a, b);\n        //output: 1,2;\n        // const a = b = 2 等价于　在全局声明const b = 2; 内部声明const a = b;因为=运算符是重右像左运算的\n    ```\n---\n#### 附录\n * [MDN连接文档](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n * [lodash相关技巧](http://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting)\n * [10个ES6可以代替lodash的方法](https://www.sitepoint.com/lodash-features-replace-es6/)","tags":["JavaScript"],"categories":["编程语言"]},{"title":"Object","url":"/2017/09/29/object/","content":"\n### Object属性：\n---\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. writable：true\n\t* 能否修改属性的值\n4. value：undefined\n\t* 包含这个属性的数据\n5. Object.defineProperty(obj, 'name', {}) (ES5)\n\n\t```\n\tObject.defineProperty(obj, 'key', {\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t\twritable: false,\n\t\tvalue: 'static'\n\t});\n\t```\n6. Object.defineProperty(obj, {})\n\t\n\t```\n\tconst obj = {};\n\tObject.defineProperties(obj, {\n\t\t\"property1\": {\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t},\t\n\t\t\"property2\": {\n\t\t\tvalue: \"Hello\",\n\t\t\twritable: false\n\t\t\t}\n\t\t});\t\n\t\n\tcosnt obj = {};\n\tObject.defineProperty(obj, 'key', {});\n\tObject.getOwnPropertyDescriptor(obj, 'key');\t\t\t\n\t// output: Object {\n\t\tvalue: undefined, \n\t\twritable: false, \n\t\tenumerable: false, \n\t\tconfigurable: false}\n\t\t\n\t// 注意：在这样定义时候，非定义的configurable等为false\n\tobj.name = 'lty';\n\t//这样定义的时候，configurable等才为true\n\t\n\t```\n7. 一旦把configurable设为false，就不能设回成true，即一切配置都不可使用。\n\n---\n### 访问器属性\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. get: undefined\n\t* 读取数据时候调用\n4. set：undefined\n\t* 写入属性时候调用\n5. 访问器属性不能直接定义，只能使用Object.defineProperty()来定义\n6. 因为 primitive 是 immutable 的,所以赋值分配新的内存,即为写入\n\n\t```\n\t\tconst book = {\n\t\t\t_year: 2004,\n\t\t\tedition: 1,\n\t\t}\n\t\tObject.defineProperty(book, 'year', {\n\t\t\tget: () => this._year,\n\t\t\tset: newline => {\n\t\t\t\tif\t(newline > 2000) {\n\t\t\t\t\tthis._year = newline;\n\t\t\t\t\tthis.edition += 1;\n\t\t\t\t};\n\t\t\t},\n\t\t})\n\t\tbook.year = 2005;\n\t\tconsole.log(edition);\n\t\t// output: 2\n\t```\n7. 浏览器中一般是使用_defineGetter_和_defineSetter_来代替\t","tags":["JavaScript"],"categories":["编程语言"]},{"title":"个人插件","url":"/2017/09/29/个人插件/","content":"\n### Alfred的相关插件\n---\n* AboutThisMac: 列出系统相关配置信息\n* colors: 前端选取颜色列表，查询颜色rgb,hsl值等\n* Hash: 文件hash加密\n* KD: 快递快速查询\n* npm: npmio快速查询\n* RMB: 人民币数汉转换\n* shanbay: 扇贝中英文翻译\n* StackOverflow: stackoverflow快速查询\n* YD: 有道词典中英文翻译\n* YDI: 有道词典加强中英文翻译\n---\n### Chrome的相关插件\n\n---\n* 1Password: 密码管理\n* Advanced REST client: 正则表达式\n* Checker Plus for Gmail: Gmail邮箱\n* Chrono Download Manager: 下载器\n* Hide Files on GitHub: 隐藏Github的所有只有扩展名文件\n* History Trends: chrome历史浏览记录\n* IcoMoon: icoMoon网站\n* Insight.io for Github: github的tree推荐\n* Isometric Contributions: github的commit大楼\n* JavaScript Errors Notifier: JavaScript的浏览器报错\n* JSON Formatter: JSON格式自动切换\n* OneTab: 所有Tab页面集合一个Tab页面\n* OctoLinker: github代码包连接跳转\n* npmhub: npmhub包自动跳转\n* Pocket: plan记录\n* Postman: api请求测试\n* Proxy SwitchyOmega: 翻墙代理必备\n* Quick Javascript Switcher: 快速关闭JavaScript脚本使用\n* Scratch JS: 浏览器内置coderunnner\n* Speedtest by Ookla: 网页测速\n* Tampermonkey: 插件大合集搜索网站,可查找需要的插件\n* The Great Suspender: 自动挂载长期未使用的页面，节省内存空间\n* Vimium: 网页版vim\n* WhatFont: 查看当前网页标签内字体\n* ZenHub for GitHub: Github中的board\n\n---\n\n### VScode 插件合集\n\n---\n* Auto Rename Tag: HTML自动修改标签\n* Auto-Open Markdwon Preview: 编写markdown必备，自动开启Preview模式\n* AutoFileName: 文件名字自动提示\n* Can I Use: CSS兼容性显示\n* Code Runner: 代码运行环境\n* Color Hightlight: 颜色自动显色\n* Docker: Docker管理\n* Document this: 自动添加注释\n* EditorConfig for VSCode: 文件格式自动整理\n* Git History: git log记录查看\n* Git lens: 代码编写提交历史查看\n* JavaScript code snippets: JavaScript的snippets\n* kubernetes Support: kubernetes的配置文件\n* Nodejs Modules Intellisense: node内置模块包提示\n* npm: npm包的提示操作，记录哪些包未使用或者未安装\n* npm Dependency: 可自动更新npm包的相关版本\n* Project Manager: 项目管理\n* Setting Sync: 插件同步管理\n* vscode-icons: vscode的Icon图标\n\n---\n* 希望各位大佬来补充，相互交流，扩充插件库\n\n\n- Github地址: https://github.com/smile-soul\n- 个人Blog: http://www.smilesoul.cn/\n\n","tags":["tools"],"categories":["开发工具"]},{"title":"前端构建工具介绍","url":"/2017/08/07/前端构建工具介绍/","content":"\n### Grunt and Gulp(构建工具)\n-----\n#### 两者优缺点对比\n\n1. Grunt 有一个完善的社区，插件丰富. 它简单易学。（大约4000+\b，\b将近Gulp两倍);\n2. Grunt 是基于文件流，Gulp是基于管道流。\n3. Grunt 的缺点\n    * 但插件很难遵守单一责任原则。比如说要对处理后的文件进行更名操作，你可能使用的是 uglify 插件，也有可能使用的是 concat 插件（取决于工作流的最后一个环节是谁）。对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在个人看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个独立的组（Files），任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。\n    * 用插件做一些本来不需要插件来做的事情。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 karma start）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。\n    * 试图用配置文件完成所有事，结果就是混乱不堪。规模较大，构建／分发／部署流程较为复杂的项目，其 Gruntfile有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”。 \n    * 落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后。\n\nGruntfile.js范例\n```\nmodule.exports = function(grunt) {\n    grunt.initConfig({\n        concat: {\n            'dist/all.js': ['src/*.js']\n        },\n        uglify: {\n            'dist/all.min.js': ['dist/all.js']\n        },\n        jshint: {\n            files: ['gruntfile.js', 'src/*.js']\n        },\n        watch: {\n            files: ['gruntfile.js', 'src/*.js'],\n            tasks: ['jshint', 'concat', 'uglify']\n        }\n    });\n    // Load Our Plugins\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-concat');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    // Register Default Task\n    grunt.registerTask('default', ['jshint', 'concat', 'uglify']);\n};\n```\nGulpfile.js范例\n```\nconst gulp = require('gulp');\nconst jshint = require('gulp-jshint');\nconst concat = require('gulp-concat');\nconst uglify = require('gulp-uglify');\nconst rename = require('gulp-rename');\n  \n// 语法检查\ngulp.task('jshint', function () {\n    return gulp.src('src/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n  \n// 合并文件之后压缩代码\ngulp.task('minify', function (){\n     return gulp.src('src/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('dist'))\n        .pipe(uglify())\n        .pipe(rename('all.min.js'))\n        .pipe(gulp.dest('dist'));\n});\n  \n// 监视文件的变化\ngulp.task('watch', function () {\n    gulp.watch('src/*.js', ['jshint', 'minify']);\n});\n  \n// 注册缺省任务\ngulp.task('default', ['jshint', 'minify', 'watch']);\n```\n附录\n* Gulp插件库: http://gulpjs.com/plugins\n* Gulp API: https://github.com/gulpjs/gulp/blob/master/docs/API.md\n* Grunt API: https://gruntjs.com/api/grunt\n\n### Browserify and Webpack(模块化工具)\n1. seajs / requirejs : 是一种在线\"编译\" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module , 也就实现了模块化。\n2. browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先它是预编译的，不需要在浏览器中加载解释器。它也是基于文件流的，相较于WebPack，Browserify能够对处理过程做更精细的控制，而WebPack相对更加‘黑盒’。还有就是WebPack的生态要比Browserify好得多。\n\n### Npm, yarn, bower\n1. npm安装依赖包的时候，会将包的不同版本放在合适的地方，从而，可以在想要的地方加载想要的版本。但是，这样对于前端来说，就是噩梦了(比如有两个版本的jQuery，或者两个版本的Bootstrap)。\n2. npm是为JavaScript服务的包管理器，目前的仓库中大多数都是Node.js包，使用Browserify进行适配之后，某些模块可以在客户端运行，但还有很多仍然不行。\n3. npm会创建一个树形的依赖关系，而bower创建的是扁平化的层级依赖关系。\n4. 树形的依赖关系的意思就是每一个包都可以有他自己的依赖包。在服务器上，这样做很好，并不用太关心空间不够用什么的。但是，在前端，这样就显得很不友好了，想象一下一个网站同时加载了三个不同版本的jQuery。\n5. bower安装的目录结构是扁平的。相互依赖的包会被放到同一级目录下。由于目录扁平化，所以，发生版本冲突的时候，需要人工解决。这样，任何人得到这个项目，安装的包的版本都是相同的了。\n\n### Yeoman\n1. Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。","tags":["framework"],"categories":["前端构建"]},{"title":"原型函数Construction解析","url":"/2016/07/06/JavaScript-constructor/","content":"\n### 理解原型之间的关系\n\n```\n    testOne() {};\n    testOne.prototype\n    // Object {\n            constructor: a()\n                    arguments: null\n                    caller: null\n                    length: 0\n                    name:\"a\"\n                    prototype: Object\n                    __proto__: ()\n                    <function scope>\n                    //注意层级关系\n            __proto__: Object\n        }\n        \n        \n    testOne.length\n    // output: 0\n    \n    \n    testOne.prototype.name = '2';\n    testOne.name\n    // output: 'a';\n```\n**注意**: 这里输出为'a'，而不是２，它会去查constructor里面的name，因为prototype.constructor是会指回testOne，如果要获取＇２＇，只能testOne.prototype.name来获取.\n\t\n```\t\t\t\n    const testTwo = new testOne();\n    testTwo.prototype\n    //output: undefined\n```\n\n**注意**: 每创建一个函数才会创建它的prototype对象，使用new，不会创建prototype对象\n    \n```   \n    testTwo.constructor\n    //output: testOne(){}\n    \n    testTwo.constructor.name = 'b';\n    testTwo.name\n    // output: testTwo\n    \n    Object.getOwnPropertyDescriptor(ｔｅｓｔTwo, 'name');\n    // output: {value: \"testTwo\", writable: false, enumerable: false, configurable: true} \n```\n\n所有原声的只可以delete，之后testOne.name输出为＇＇，不能修改.\n\n```\n    testTwo.constructor.names = 'c';\n    testTwo.names\n    // output: c\n    \n    Object,getOwnPropertyDescriptor(testTwo, 'names');\n    // output: {value: \"c\", writable: true, enumerable: true, configurable: true}\n```\n\n非原生的属性，添加之后可以修改,所以在执行new操作时，将tetTwo的指针指向了\btestTwo.constructor\n\t\n```\n    testOne.prototype.newOne = '5';\n    testTwo.newOne\n    // output: '5'\n    testTwo.newOne = '6';\n    testTwo.newOne\n    // output: '6'\n    testTwo\n    // output: \n        bbb:\"444\"\n        __proto__:\tObject\n            bbb: \"2\"\n            constructor: d()\n            ＿_proto__: Object\n```\n\nnewOne　屏蔽掉了原属性，因为将怎么testOne的指针指＿proto＿\n\n```\n    Object.keys(testTwo);\n    // output: ['bbb']    \n```\n\n这也是为什么Object.keys只出现bbb，因为＿proto＿，constructor不可枚举.\n\n\n```\n    const name(){};\n    name.prototype;\n    // output: constructor: name()\n                __proto__:Object               \n    const nameTwo(){};\n    nameTwo.prototype = {};\n    nameTwo.prototype;\n    // output: __proto__:Object\n```\n这也切断了与原型之间的联系，constructor变成了＿ｐｒｏｔｏ＿的属性\n\n\n```\n    const nameThree(){};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: { writable: true, enumerable: false, configurable: true }\n    nameThree.prototype = { constructor: nameThree};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: {writable: true, enumerable: true, configurable: true}\n```\n\n操作prototype会使，constructor消失，如果手动改变，这会使constructor种的enumerable变成true（即可枚举）\t","tags":["JavaScript"],"categories":["编程语言"]}]